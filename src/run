#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bridge `process_download_logs` and `annotate_download_logs.py` producing CSV
individual session (using `annotate_download_logs.py`) for every output file
produced by `process_download_logs`
"""
import os
import json
import subprocess
from typing import BinaryIO
import process_download_logs
from datetime import datetime, timedelta

MODES = json.loads(os.getenv('MODES'))
OUTDIR = os.environ['OUTDIR']
CACHEDIR = os.environ['CACHEDIR']
CUTOFF_DAYS = int(os.environ['CUTOFF_DAYS'])


def outstream(filename: str) -> BinaryIO:
    return open(filename, "w")


def instream(filename: str) -> BinaryIO:
    return open(filename, "r")


def get_sessions_filename(odir: str) -> str:
    return f"{odir}/AccessLogs.csv"


def old_or_empty_out_files():
    cutoff = datetime.now() - timedelta(days=CUTOFF_DAYS)
    for mode in MODES:
        out_file = process_download_logs.get_output_filename(
            CACHEDIR,
            mode['name']
        )
        try:
            size = os.path.getsize(out_file)
            time = datetime.fromtimestamp(os.path.getctime(out_file))
            assert size > 0 and time > cutoff
        except BaseException:
            return True
    return False


def run():
    """
    Produce output files if they are empty,
    missing, or older than cutoff.
    Comment out this if for endto end testing purposes."""
    if old_or_empty_out_files():
        process_download_logs.run()

    i = 0
    ses_file = get_sessions_filename(OUTDIR)
    output = outstream(ses_file)
    for mode in MODES:
        out_file = process_download_logs.get_output_filename(
            CACHEDIR,
            mode['name']
        )
        # only include headers in first iteration
        headers = ['--add-headers'] if i == 0 else []
        i += 1
        cmd = [
            './annotate_download_logs', '--measure', mode['measure']
        ] + headers
        subprocess.call(cmd, stdout=output, stdin=instream(out_file))
        result = subprocess.run(cmd, stdout=output, stdin=instream(out_file))
        result.stdout


if __name__ == '__main__':
    run()
